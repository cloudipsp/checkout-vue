<template>
  <div class="f-wrapper" :data-e2e-ready="ready">
    <f-sidebar v-if="showSidebar" />
    <div ref="center" class="f-center">
      <f-scrollbar-vertical wrap-class="f-center-wrap">
        <div class="f-top">&nbsp;</div>
        <!--payment-method success-->
        <component :is="page" :order="order" />
        <f-loading v-if="loading" backdrop />
        <f-modal-error />
        <f-modal-3ds
          v-model="show3ds"
          :duration.sync="duration3ds"
          @submit3ds="submit3ds"
        />
        <f-security class="f-center-security" />
        <f-alert-gdpr v-model="showGdprFrame" />
      </f-scrollbar-vertical>
    </div>
  </div>
</template>

<script>
import Success from '@/components/success'
import PaymentMethod from '@/components/payment-method'
import FSidebar from '@/components/sidebar'
import FModalError from '@/components/modal/modal-error'
import FSecurity from '@/components/security'
import FAlertGdpr from '@/components/alert/alert-gdpr'

import { errorHandler } from '@/utils/helpers'
import { isExist } from '@/utils/typeof'
import FModal3ds from '@/components/modal/modal-3ds'
import { mapState, mapStateGetSet } from '@/utils/store'
import loadButton from '@/store/button'
import { methods, tabs } from '@/utils/compatibility'
import getCardBrand from '@/utils/card-brand'
import timeout from '@/mixins/timeout'

let model3ds

export default {
  provide() {
    return {
      formRequest: this.formRequest,
      submit: this.submit,
    }
  },
  components: {
    Success,
    PaymentMethod,
    FSidebar,
    FModal3ds,
    FModalError,
    FSecurity,
    FAlertGdpr,
  },
  mixins: [timeout],
  inject: ['$validator'],
  data() {
    return {
      timeoutId: 0,
      order: {},
      show3ds: false,
      duration3ds: 0,
      showGdprFrame: false,
    }
  },
  computed: {
    ...mapState(['loading']),
    ...mapState('router', ['page', 'method']),
    ...mapState('params', ['token']),

    ...mapStateGetSet([
      'ready',
      'cards',
      'tabs',
      'verification_type',
      'need_verify_code',
      'validate_expdate',
      'region',
      'submited',
    ]),
    ...mapStateGetSet('options', [
      'email',
      'link',
      'title',
      'logo_url',
      'offerta_url',
      'methods',
      'methods_disabled',
      'default_country',
      'customer_fields',
    ]),
    ...mapStateGetSet('params', [
      'lang',
      'fee',
      'order_desc',
      'amount',
      'currency',
      'merchant_id',
      'order_id',
      'card_number',
      'expiry_date',
      'cvv2',
    ]),
    createdFormParams() {
      return this.token ? { token: this.token } : this.store.formParams()
    },
    showSidebar() {
      return !(this.page === 'success' && this.method === 'approved')
    },
  },
  created() {
    this.createdEvent()

    if (this.token) {
      this.store.formLoading(true)
    }

    loadButton()
      .then(
        response => {
          this.store.setButtonParams(response)
        },
        () => {}
      )
      .then(() => {
        return this.store.sendRequest(
          'api.checkout',
          'app',
          this.createdFormParams
        )
      })
      .finally(() => {
        this.ready = true
        this.store.formLoading(false)
      })
      .then(this.appSuccess)
      .catch(errorHandler)
  },
  methods: {
    submit() {
      this.submited = true
      return this.$nextTick()
        .then(() => this.$validator.validateAll())
        .then(isValid => {
          this.store.state.isSubmit = true
          // this.errors.items this.fields this.errors.clear() this.errors.count()

          if (!isValid) return this.autoFocus()

          return this.formRequest()
        })
        .finally(() => {
          this.submited = false
        })
    },
    formRequest(data) {
      if (this.loading) return Promise.reject()
      this.store.formLoading(true)

      return this.store
        .sendRequest(
          'api.checkout.form',
          'request',
          Object.assign(this.store.formParams(), data)
        )
        .finally(() => {
          this.store.formLoading(false)
        })
        .then(this.submitSuccess, this.submitError)
    },
    submitSuccess(model) {
      if (!model) return
      this.$root.$emit('success', model)

      this.location(model.instance(model.alt('order', model.data)))
      this.submit3dsSuccess(model)

      return model
    },
    submitError(model) {
      this.$root.$emit('error', model)
      return Promise.reject(model)
    },
    appSuccess(model) {
      this.$root.$emit('ready', model)
      this.infoSuccess(model.instance(model.attr('info')))
      this.orderSuccess(model.instance(model.attr('order')))
      this.cardsSuccess(model.instance(model.attr('cards')))
    },
    cardsSuccess(model) {
      if (this.need_verify_code || !Array.isArray(model.data)) return
      if (!model.data.length) return

      this.cards = this.cardsParse(model.data)

      this.store.setCardNumber(this.cards[0])
    },
    cardsParse(data) {
      return data.map(item => {
        let card_number = item.card_number.replace(/ /g, '')
        let expiry_date = item.expiry_date.replace(/ /g, '')

        return {
          ...item,
          card_number,
          expiry_date,
          card_brand: getCardBrand(card_number),
        }
      })
    },
    infoSuccess(model) {
      if (isExist(model.attr('validate_expdate'))) {
        this.validate_expdate = model.attr('validate_expdate')
      }
      this.link = model.attr('merchant_url') || this.link
      this.email = model.attr('checkout_email_required') || this.email
      this.title = this.title || model.attr('merchant.localized_name')
      this.logo_url = this.logo_url || model.attr('merchant.logo_url')
      this.offerta_url = this.offerta_url || model.attr('merchant.offerta_url')
      this.region = model.attr('merchant.country').toLowerCase()

      if (model.attr('tabs_order') && model.attr('tabs_order').length) {
        this.methods = methods(model.attr('tabs_order'), this.methods_disabled)
        this.store.initLocation()
        this.store.initOnlyCard()
      }
      this.tabs = tabs(model.attr('tabs'))
      this.default_country =
        this.store.attr('user.options.default_country') ||
        model.attr('default_country')

      this.fee = model.attr('client_fee') || 0
      this.customer_fields = model.attr('customer_required_data') || []

      this.order_desc = this.order_desc || model.attr('order.order_desc')

      if (model.attr('order.verification')) {
        this.verification_type = model.attr('verification_type')
        this.title = 'verification_t'
        this.order_desc = 'verification_' + this.verification_type + '_d'
      }

      this.store.setRecurring(model.attr('order'))

      this.showGdprFrame = model.attr('show_gdpr_frame')
    },
    orderSuccess(model) {
      let order_data = model.attr('order_data')

      if (!order_data) return

      this.location(model)

      this.amount = order_data.amount
      this.currency = order_data.currency
      this.merchant_id = order_data.merchant_id
      this.store.state.params.email =
        order_data.sender_email || this.store.state.params.email
      this.order_id = order_data.order_id
    },
    submit3dsSuccess(model) {
      if (!model.waitOn3dsDecline()) return

      this.show3ds = true
      this.duration3ds = model.waitOn3dsDecline()
      model3ds = model
    },
    location(model) {
      //        console.warn('model.inProgress()', 'order.in_progress', model.inProgress())
      //        console.warn('model.readyToSubmit()', 'order.ready_to_submit', model.readyToSubmit())
      //        console.warn('model.waitForResponse()', 'order.pending', model.waitForResponse())
      //        console.warn('model.needVerifyCode()', 'order.need_verify_code', model.needVerifyCode())
      //        console.warn('model.submitToMerchant()', model.submitToMerchant())

      if (model.sendResponse()) return // action === 'submit' formDataSubmit() || action === 'redirect' redirectUrl()

      if (
        this.$root._events.callback &&
        this.$root._events.callback.length &&
        model.attr('ready_to_submit')
      )
        return this.$root.$emit('callback', model)

      if (model.submitToMerchant()) return // ready_to_submit && response_url && order_data formDataSubmit()

      if (model.needVerifyCode()) {
        // need_verify_code
        this.need_verify_code = true
        this.verification_type = model.attr('verification_type')
        this.title = 'verification_t'
        this.order_desc = 'verification_' + this.verification_type + '_d'
        this.card_number = model.attr('order_data.masked_card')
        this.expiry_date = model.attr('order_data.expiry_date')
        this.cvv2 = ''
        this.store.location('payment-method', 'card')
      } else if (model.inProgress() && model.waitForResponse()) {
        this.locationPending()
      } else if (model.inProgress()) {
        this.order = model.attr('order_data')
        this.store.location('success', this.order.order_status)
      }
    },
    locationPending() {
      if (this.loading) return
      this.store.formLoading(true)
      this.processingTimeout = setTimeout(() => {
        this.store
          .sendRequest('api.checkout.order', 'get', this.store.formParams())
          .finally(() => {
            this.store.formLoading(false)
          })
          .then(this.orderSuccess)
          .catch(errorHandler)
      }, 15 * 1000)
      if (!this.processingClear) {
        this.processingClear = setTimeout(() => {
          this.processingClear = null
          this.store.formLoading(false)
          clearTimeout(this.processingTimeout)
        }, 2 * 30 * 1000)
      }
    },
    createdEvent() {
      this.$root.$on('submit', this.submit)
      this.$root.$on('location', (method, system) => {
        this.store.location('payment-method', method, system)
      })
      this.$root.$on('setParams', this.store.setParams)
    },
    autoFocus() {
      let $firstErrorField = this.$el.querySelector(
        '#' + this.errors.items[0].field
      )
      $firstErrorField.scrollIntoView()
      this.timeout(() => {
        $firstErrorField.focus()
      })

      return Promise.reject()
    },
    submit3ds() {
      model3ds.submit3dsForm()
    },
  },
}
</script>
